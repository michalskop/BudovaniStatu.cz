(function() {
  /* 
  * Important note:
  *
  * The source of this JS file is auto-generated by CoffeeScript.
  * Changes made here will be overwritten. Please make your changes
  * in svgmap.coffee
  *
  */
  var SVGMap;
  SVGMap = (function() {
    function SVGMap(config) {
      var _ref, _ref2;
      this.svgSrc = config.svg;
      this.container = config.container;
      this.mode = (_ref = config.mode) != null ? _ref : 'percapita';
      this.getTooltip = (_ref2 = config.tooltip) != null ? _ref2 : this.defaultTooltip;
      this.loadSVG();
    }
    SVGMap.prototype.loadSVG = function() {
      $.ajax({
        url: this.svgSrc,
        context: this,
        success: this.svgLoaded
      });
    };
    SVGMap.prototype.svgLoaded = function(svg) {
      var path, paths, regionMapSrc, region_id, svgRoot, _i, _len, _ref;
      svgRoot = svg.getElementsByTagName('svg')[0];
      this.mapSrcWidth = this.valueFromPixel(svgRoot.getAttribute('width'));
      this.mapSrcHeight = this.valueFromPixel(svgRoot.getAttribute('height'));
      paths = svg.getElementsByTagName('path');
      regionMapSrc = {};
      this.populationPerRegion = {};
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        if ((path.getAttribute != null) && path.getAttribute('class') === 'region' && (path.getAttribute('d') != null)) {
          region_id = path.getAttribute('region');
          if ((_ref = regionMapSrc[region_id]) == null) {
            regionMapSrc[region_id] = [];
          }
          regionMapSrc[region_id].push(path.getAttribute('d'));
          if (path.getAttribute('population') != null) {
            this.populationPerRegion[region_id] = path.getAttribute('population');
          }
        }
      }
      this.mapSrc = regionMapSrc;
      this.initMap();
    };
    SVGMap.prototype.valueFromPixel = function(px) {
      return Number(px.substr(0, px.length - 2));
    };
    SVGMap.prototype.initMap = function() {
      var id, path, pathSrcs, ps, _i, _len, _ref;
      this.paper = new Raphael(this.container[0], this.container.width(), this.container.height());
      this.paths = [];
      this.pathsByRegion = {};
      _ref = this.mapSrc;
      for (id in _ref) {
        pathSrcs = _ref[id];
        this.pathsByRegion[id] = [];
        for (_i = 0, _len = pathSrcs.length; _i < _len; _i++) {
          ps = pathSrcs[_i];
          path = this.createPath(ps);
          this.paths.push(path);
          path.node.setAttribute('region:id', id);
          path.node.setAttribute('map:instance', this);
          this.pathsByRegion[id].push(path);
          $(path.node).tooltip({
            delay: 100,
            bodyHandler: this.getRegionTooltip.bind(path.node)
          });
        }
      }
      this.scaleMap();
      $(window).resize(this.scaleMap.bind(this));
    };
    SVGMap.prototype.createPath = function(src) {
      var path;
      return path = this.paper.path(src).attr({
        fill: '#ccc',
        stroke: false
      });
    };
    SVGMap.prototype.getRegionTooltip = function() {
      var map, rid;
      map = this.getAttribute('map:instance');
      rid = this.getAttribute('region:id');
      return this.getAttribute('tooltip');
    };
    SVGMap.prototype.scaleMap = function() {
      var h, path, scale, transform, w, xo, yo, _i, _len, _ref, _ref2;
      _ref = [this.container.width(), this.container.height()], w = _ref[0], h = _ref[1];
      this.paper.setSize(w, h);
      scale = Math.min(h * 0.85 / this.mapSrcHeight, w * 0.85 / this.mapSrcWidth);
      xo = (w - this.mapSrcWidth * scale) * 0.5;
      yo = (h - this.mapSrcHeight * scale) * 0.5;
      this.container.css({
        'padding-top': yo + 'px',
        'padding-left': xo + 'px'
      });
      transform = "scale(" + scale + ")";
      _ref2 = this.paths;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        path = _ref2[_i];
        path.node.setAttribute("transform", transform);
      }
    };
    SVGMap.prototype.updateValues = function(node) {
      var breakdowns, color, hue, id, ma, match, path, paths, population, subnode, tooltip, total, _i, _len, _ref;
      this.currentNode = node;
      total = node.amount;
      ma = 0;
      match = false;
      for (id in this.pathsByRegion) {
        if (node.breakdowns[id] != null) {
          match = true;
        }
      }
      breakdowns = match ? node.breakdowns : node.breakdownsByName;
      hue = vis4color.fromHex(node.color).h;
      for (id in breakdowns) {
        subnode = breakdowns[id];
        if (this.pathsByRegion[id] != null) {
          population = this.populationPerRegion[id];
          switch (this.mode) {
            case 'total':
              ma = Math.max(ma, subnode.amount);
              break;
            case 'percapita':
              ma = Math.max(ma, subnode.amount / population);
          }
        }
      }
      _ref = this.pathsByRegion;
      for (id in _ref) {
        paths = _ref[id];
        if ((node.breakdownsByName[id] != null) || (node.breakdowns[id] != null)) {
          subnode = node.breakdowns[id] != null ? node.breakdowns[id] : node.breakdownsByName[id];
          population = this.populationPerRegion[id];
          switch (this.mode) {
            case 'total':
              color = vis4color.fromHSL(hue, .3, .9 - subnode.amount / ma * .5).x;
              break;
            case 'percapita':
              color = vis4color.fromHSL(hue, .3, .9 - (subnode.amount / population) / ma * .5).x;
          }
          tooltip = this.getTooltip(this, node, subnode, population);
        } else {
          tooltip = this.getTooltip(this, node);
          color = '#bbb';
        }
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          path = paths[_i];
          path.node.setAttribute('tooltip', tooltip);
          path.animate({
            fill: color
          }, 300);
        }
      }
    };
    SVGMap.prototype.defaultTooltip = function(map, node, subnode, population) {
      if (subnode == null) {
        subnode = null;
      }
      if (population == null) {
        population = void 0;
      }
      if (subnode != null) {
        return subnode.label + '<br />' + (subnode != null ? subnode.famount : 'n/a');
      }
    };
    return SVGMap;
  })();
  window.SVGMap = SVGMap;
}).call(this);
